


### alignment
bash /var/pipelines_ngs_test/shell/bwaAlign_exome.sh /home/nextseq/181029_NS500761_0258_AH2JH2BGX9/out1/COV-1_S1_R1_001.fastq.gz   /home/nextseq/181029_NS500761_0258_AH2JH2BGX9/out1/COV-1_S1_R2_001.fastq.gz     /home/hhadmin/exome/bamQC/run_258_analysis



##this can be confirmed by running individual filters
samtools view sample.bam | wc -l
### -f to keep and -F to filter out
samtools view -F 4 sample.bam | wc -l #  filtering out unmapped
samtools view -f 0x0040 sample.bam | wc -l  # total read1
samtools view -f 0x0080 sample.bam | wc -l  ## total reads2

# FLAG: bitwise FLAG. Each bit is explained in the following table:
#
# Bit	Description
# 0x1	  template having multiple segments in sequencing
# 0x2	  each segment properly aligned according to the aligner
# 0x4	  segment unmapped
# 0x8	  next segment in the template unmapped
# 0x10	 SEQ being reverse complemented
# 0x20	 SEQ of the next segment in the template being reversed
# 0x40	 the first segment in the template
# 0x80	 the last segment in the template
# 0x100	 secondary alignment
# 0x200	 not passing quality controls
# 0x400	 PCR or optical duplicate
# 0x800	 supplementary alignment
#
#
# Those 0x1, 0x2, â€¦ are hexadecimal numbers (base 16) as opposed to decimal numbers (base 10). We can represent the table in decimal numbers:
#
# Decimal	Description
# 1	    template having multiple segments in sequencing
# 2	    each segment properly aligned according to the aligner
# 4	    segment unmapped
# 8	    next segment in the template unmapped
# 16	SEQ being reverse complemented
# 32	SEQ of the next segment in the template being reversed
# 64	the first segment in the template
# 128	the last segment in the template
# 256	secondary alignment
# 512	not passing quality controls
# 1024	PCR or optical duplicate
# 2048	supplementary alignment

# What about all the other numbers? Well, they are simply combinations of the above table;
# for example, the BAM flag 1040 is 1024 + 16. Reads with a BAM flag of 1040, have the properties
#  of being mapped on the reverse strand AND are PCR duplicates. There is only one way of adding the numbers up.

# this webtool translates code
# http://broadinstitute.github.io/picard/explain-flags.html

#### collect more stats from sam files
######  picard

java -jar /opt/picard/picard-tools-1.134/picard.jar CollectAlignmentSummaryMetrics  R=/home/doc/ref/ref_genome/ucsc.hg19.fasta I=sample.sort.bam  O=piccard_bamstats.txt
java -jar /opt/picard/picard-tools-1.134/picard.jar BedToIntervalList  I=COV-1.bed O=COV-1._bed.interval_list SD=/doc/ref/ref_genome/ucsc.hg19.dict



### what is difference between insert size, fragment size, and inner mate distance
http://thegenomefactory.blogspot.com/2013/08/paired-end-read-confusion-library.html

#### for chromosome wise map and unmapped reads
#output where each line consists of ref.seq. name, ref.seq. length, number of mapped reads and number of unmapped reads.
/opt/samtools/samtools idxstats sample.bam

# One can easily use samtools and bamToBed together as part of a UNIX pipe.
# In this example, we will only convert properly-paired (BAM flag == 0x2) reads to BED format.
# -s is for input is sam, -b is for output is bam -f is for select only flag 0x2

/opt/samtools/samtools view -bf 0x2 sample.bam | /opt/bedtools2/bin/bedtools bamtobed -i stdin > sample.bed

# get only reads with two pairs
 awk '{print $1 "\t" $2 "\t" $3 }' sample.bed > sample_mod.bed

#run bedtools and get required information i.e. gene or postion
/opt/bedtools2/bin/bedtools intersect -a sample_mod.bed -b db_01_clinvar_modified2.vcf -wa -wb | awk '{print $8}' > out_clinvar_v7_intersect_genes.csv

###########################################
### GET COVERAGE FROM BAM FILE
##############################
samtools view -F input.bam > forward.bam
samtools view -f input.bam > reverse.bam
samtools depth -a forward.bam > forwardDepth.txt
samtools depth -a reverse.bam > reverseDepth.txt
paste forwardDepth.txt reverseDepth.txt > forwardAndReverse.txt

# coverage against total base
#Computes the depth at each position or region. a -a, -aa: Output absolutely all positions, including unused reference sequences
 /opt/samtools/samtools depth sample.bam > coverage
awk '{ if($3 > 10){print $0}}' coverage |wc -l
 awk '{sum+=$1} END { print "Average = ",sum/3095693981}' > output.txt


# Use genomecov to get the coverage all across the genome:
#Or just coverage if you have a specific gff/bed file with the region that you want to determine the coverage for:

# coverage against target
/opt/bedtools2/bin/bedtools coverage -a ../../in_design_files/v7/design.bed -b sample.bed -d > bedcoverage
awk '$5>10 {print}' bedcoverage | wc -l
awk '$5>50 {print}' bedcoverage | wc -l
awk '$5>100 {print}' bedcoverage | wc -l

#mean depth of coverage for each interval specified in your BED file
# OPTIONAL merge your bed file for more accuracy
 /opt/bedtools2/bin/bedtools merge -i sample.bed > sample_merge.bed

/opt/bedtools2/bin/bedtools coverage -a ../../in_design_files/v7/design.bed -b sample.bed  -mean > bedcoverage_mean
awk '{total+=$4} END {print total/NR}' bedcoverage_mean


### for genome COVERAGE- this will merge the adjacent bb so number will be less than samtools depth
/opt/bedtools2/bin/bedtools genomecov -ibam sample.bam -bga -split  > coverage_genomecov


## calculate size
awk '{print $1 "\t" $2 "\t" $3 "\t" $3-$2}' sample.bed > sample_withsize.bed
awk '{total+=$4} END {print total}' sample_withsize.bed
